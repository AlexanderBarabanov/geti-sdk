import glob
import os
import time
from typing import Dict, List

from sc_api_tools.data_models import Project
from sc_api_tools.http_session import SCSession


class MediaManager:
    """
    Class to manage media uploads for a certain project
    """

    def __init__(self, session: SCSession, workspace_id: str, project: Project):
        self.session = session
        project_id = project.id
        dataset_id = project.datasets[0].id
        self.base_url = f"workspaces/{workspace_id}/projects/{project_id}/datasets/" \
                        f"{dataset_id}/media"
        self._project_name = project.name

    def get_all_images(self) -> Dict[str, str]:
        """
        Get the ID's and filenames of all images in the project

        :return: Dictionary containing the ID's (as keys) and filenames (as values)
            of the images in the project
        """
        response = self.session.get_rest_response(
            url=f"{self.base_url}/images?top=100000",
            method="GET"
        )
        total_number_of_images: int = response["media_count"]["images"]
        name_to_id_mapping: Dict[str, str] = {}
        while len(name_to_id_mapping) < total_number_of_images:
            for image in response["media"]:
                id_ = image["id"]
                filename = image["name"]
                # Check for duplicate filenames
                mapped_filename = None
                if filename not in name_to_id_mapping.keys():
                    mapped_filename = filename
                else:
                    for index in range(0, total_number_of_images):
                        new_filename = filename+f'_copy_{index}'
                        if new_filename not in name_to_id_mapping.keys():
                            mapped_filename = new_filename
                            break
                if mapped_filename is not None:
                    name_to_id_mapping.update({mapped_filename: id_})
                else:
                    print(
                        f"Unable to determine valid, unique filename for image with id "
                        f"{id_}. Skipping image retrieval for this image."
                    )
            if "next_page" in response.keys():
                response = self.session.get_rest_response(
                    url=response["next_page"],
                    method="GET"
                )
        return name_to_id_mapping

    def upload_image(self, filepath_to_image: str) -> str:
        """
        Upload an image file to the server

        :param filepath_to_image: full path to the image on disk
        :return: String containing the unique ID of the image, generated by Sonoma
            Creek
        """
        image_bytes = open(filepath_to_image, 'rb')
        response = self.session.get_rest_response(
            url=f"{self.base_url}/images",
            method="POST",
            contenttype="multipart",
            data={"file": image_bytes}
        )
        return response.json()["id"]

    def __upload_loop(self, image_filepaths: List[str]) -> Dict[str, str]:
        """
        Uploads images from a list of filepaths. Also checks if images with the same
        filename exist in the project, to make sure no duplicate images are uploaded.

        :param image_filepaths: List of full filepaths for images that should be
            uploaded
        :return: Dictionary containing a mapping between the ID's of the images and
            their filenames (excluding extensions) NOTE: Filenames are used as keys,
            ID's as values
        """
        filename_id_mapping: Dict[str, str] = {}
        images_in_project = self.get_all_images()
        upload_count = 0
        skip_count = 0
        print("Starting image upload...")
        t_start = time.time()
        for image_filepath in image_filepaths:
            image_name, image_ext = os.path.splitext(os.path.basename(image_filepath))
            if image_name in images_in_project.keys():
                filename_id_mapping.update({image_name: images_in_project[image_name]})
                skip_count += 1
                continue
            image_id = self.upload_image(filepath_to_image=image_filepath)
            filename_id_mapping.update({image_name: image_id})
            upload_count += 1
            if upload_count % 100 == 0:
                print(f"Uploading... {upload_count} images uploaded successfully.")

        t_elapsed = time.time() - t_start
        if upload_count > 0:
            msg = f"Upload complete. Uploaded {upload_count} new images in " \
                  f"{t_elapsed:.1f} seconds."
        else:
            msg = "No new images were uploaded."
        if skip_count > 0:
            msg = msg + f" Found {skip_count} images that already existed in " \
                        f"project, these images were skipped."
        print(msg)

        return filename_id_mapping

    def upload_folder(self, path_to_folder: str, n_images: int = -1) -> Dict[str, str]:
        """
        Uploads all images in a folder to the project. Returns the mapping of image
        filename to the unique ID assigned by Sonoma Creek.

        :param path_to_folder: Folder with images to upload
        :param n_images: Number of images to upload from folder
        :return: Dictionary containing a mapping between the ID's of the images and
            their filenames (excluding extensions). NOTE: Filenames are used as keys,
            ID's as values
        """
        filenames = os.listdir(path_to_folder)
        n_files = len(filenames)
        if n_images == -1:
            n_to_upload = n_files
        else:
            n_to_upload = n_files if n_files < n_images else n_images
        filepaths = [
            os.path.join(path_to_folder, filename) for
            filename in filenames[0:n_to_upload]
        ]
        return self.__upload_loop(image_filepaths=filepaths)

    def upload_from_list(
        self,
        path_to_folder: str,
        image_names: List[str],
        extension_included: bool = False,
        n_images: int = -1
    ):
        """
        From a folder containing images `path_to_folder`, this method uploads only
        those images that have their filenames included in the `image_names` list.

        :param path_to_folder: Folder containing the images
        :param image_names: List of names of the images that should be uploaded
        :param extension_included: Set to True if the extension of the image is
            included in the name, for each image in the image_names list. Defaults to
            False
        :param n_images: Number of images to upload from the list
        :return: Dictionary containing a mapping between the ID's of the images and
            their filenames (excluding extensions). NOTE: Filenames are used as keys,
            ID's as values
        """
        image_filepaths: List[str] = []
        if n_images > len(image_names) or n_images == -1:
            n_to_upload = len(image_names)
        else:
            n_to_upload = n_images
        for image_name in image_names[0:n_to_upload]:
            if not extension_included:
                matches = glob.glob(os.path.join(path_to_folder, image_name)+".*")
            else:
                matches = [os.path.join(path_to_folder, image_name)]
            if not matches:
                raise ValueError(
                    f"No matching file found for image with name {image_name}"
                )
            elif len(matches) != 1:
                raise ValueError(
                    f"Multiple files found for image with name {image_name}: {matches}"
                )
            image_filepaths.append(matches[0])
        return self.__upload_loop(image_filepaths=image_filepaths)

    def download_all_images(self, path_to_folder: str) -> None:
        """
        Download all images in a project to a folder on the local disk.

        :param path_to_folder: path to the folder in which the images should be saved
        :return:
        """
        image_id_mapping = self.get_all_images()
        path_to_image_folder = os.path.join(path_to_folder, "images")
        if not os.path.exists(path_to_image_folder):
            os.makedirs(path_to_image_folder)
        print(
            f"Downloading {len(image_id_mapping)} images from project "
            f"'{self._project_name}' to folder {path_to_image_folder}..."
        )
        t_start = time.time()
        download_count = 0
        existing_count = 0
        for image_filename, image_id in image_id_mapping.items():
            image_filepath = os.path.join(path_to_image_folder, image_filename+".jpg")
            if os.path.exists(image_filepath) and os.path.isfile(image_filepath):
                existing_count += 1
                continue
            response = self.session.get_rest_response(
                url=f"{self.base_url}/images/{image_id}/display/full",
                method="GET",
                contenttype="jpeg"
            )
            with open(image_filepath, 'wb') as f:
                f.write(response.content)
            download_count += 1
        t_elapsed = time.time() - t_start
        if download_count > 0:
            msg = f"Downloaded {download_count} images in {t_elapsed:.1f} seconds."
        else:
            msg = "No images were downloaded."
        if existing_count > 0:
            msg += f" {existing_count} existing images were found in the target " \
                   f"folder, download was skipped for these images."
        print(msg)

