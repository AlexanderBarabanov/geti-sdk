import glob
import os
import time
from typing import Dict, List

from sc_api_tools.http_session import SCSession


class MediaManager:
    """
    Class to manage media uploads for a certain project
    """

    def __init__(self, session: SCSession, workspace_id: str, project: dict):
        self.session = session
        project_id = project["id"]
        dataset_id = project["datasets"][0]["id"]
        self.base_url = f"workspaces/{workspace_id}/projects/{project_id}/datasets/" \
                        f"{dataset_id}/media"

    def get_all_images(self) -> Dict[str, str]:
        """
        Get the ID's and filenames of all images in the project

        :return: Dictionary containing the ID's (as keys) and filenames (as values)
            of the images in the project
        """
        response = self.session.get_rest_response(
            url=f"{self.base_url}/images?top=100000",
            method="GET"
        )
        total_number_of_images: int = response["media_count"]["images"]
        id_to_name_mapping: Dict[str, str] = {}
        while len(id_to_name_mapping) < total_number_of_images:
            for image in response["media"]:
                id_ = image["id"]
                filename = image["name"]
                id_to_name_mapping.update({id_: filename})
            if "next_page" in response.keys():
                response = self.session.get_rest_response(
                    url=response["next_page"],
                    method="GET"
                )
        return id_to_name_mapping

    def upload_image(self, filepath_to_image: str) -> str:
        """
        Upload an image file to the server

        :param filepath_to_image: full path to the image on disk
        :return: String containing the unique ID of the image, generated by Sonoma
            Creek
        """
        image_bytes = open(filepath_to_image, 'rb')
        response = self.session.get_rest_response(
            url=f"{self.base_url}/images",
            method="POST",
            contenttype="multipart",
            data={"file": image_bytes}
        )
        return response.json()["id"]

    def __upload_loop(self, image_filepaths: List[str]) -> Dict[str, str]:
        """
        Uploads images from a list of filepaths. Also checks if images with the same
        filename exist in the project, to make sure no duplicate images are uploaded.

        :param image_filepaths: List of full filepaths for images that should be
            uploaded
        :return: Dictionary containing a mapping between the ID's of the images and
            their filenames (excluding extensions)
        """
        filename_id_mapping: Dict[str, str] = {}
        images_in_project = self.get_all_images()
        image_name_to_id = {name: id_ for id_, name in images_in_project.items()}
        upload_count = 0
        skip_count = 0
        print("Starting image upload...")
        t_start = time.time()
        for image_filepath in image_filepaths:
            image_name, image_ext = os.path.splitext(os.path.basename(image_filepath))
            if image_name in images_in_project.values():
                filename_id_mapping.update({image_name: image_name_to_id[image_name]})
                skip_count += 1
                continue
            image_id = self.upload_image(filepath_to_image=image_filepath)
            filename_id_mapping.update({image_name: image_id})
            upload_count += 1
            if upload_count % 100 == 0:
                print(f"Uploading... {upload_count} images uploaded successfully.")

        t_elapsed = time.time() - t_start
        if upload_count > 0:
            msg = f"Upload complete. Uploaded {upload_count} new images in " \
                  f"{t_elapsed:.1f} seconds."
        else:
            msg = "No new images were uploaded."
        if skip_count > 0:
            msg = msg + f" Found {skip_count} images that already existed in " \
                        f"project, these images were skipped."
        print(msg)

        return filename_id_mapping

    def upload_folder(self, path_to_folder: str, n_images: int = -1) -> Dict[str, str]:
        """
        Uploads all images in a folder to the project. Returns the mapping of image
        filename to the unique ID assigned by Sonoma Creek.

        :param path_to_folder: Folder with images to upload
        :param n_images: Number of images to upload from folder
        :return: Dictionary containing a mapping between the ID's of the images and
            their filenames (excluding extensions)
        """
        filenames = os.listdir(path_to_folder)
        n_files = len(filenames)
        if n_images == -1:
            n_to_upload = n_files
        else:
            n_to_upload = n_files if n_files < n_images else n_images
        filepaths = [
            os.path.join(path_to_folder, filename) for
            filename in filenames[0:n_to_upload]
        ]
        return self.__upload_loop(image_filepaths=filepaths)

    def upload_from_list(
        self,
        path_to_folder: str,
        image_names: List[str],
        extension_included: bool = False,
        n_images: int = -1
    ):
        """
        From a folder containing images `path_to_folder`, this method uploads only
        those images that have their filenames included in the `image_names` list.

        :param path_to_folder: Folder containing the images
        :param image_names: List of names of the images that should be uploaded
        :param extension_included: Set to True if the extension of the image is
            included in the name, for each image in the image_names list. Defaults to
            False
        :param n_images: Number of images to upload from the list
        :return:
        """
        image_filepaths: List[str] = []
        if n_images > len(image_names) or n_images == -1:
            n_to_upload = len(image_names)
        else:
            n_to_upload = n_images
        for image_name in image_names[0:n_to_upload]:
            if not extension_included:
                matches = glob.glob(os.path.join(path_to_folder, image_name)+".*")
            else:
                matches = [os.path.join(path_to_folder, image_name)]
            if not matches:
                raise ValueError(
                    f"No matching file found for image with name {image_name}"
                )
            elif len(matches) != 1:
                raise ValueError(
                    f"Multiple files found for image with name {image_name}: {matches}"
                )
            image_filepaths.append(matches[0])
        return self.__upload_loop(image_filepaths=image_filepaths)
