import os
import datetime
import tempfile
from typing import Union

import cv2
import numpy as np

from .media_manager import BaseMediaManager
from sc_api_tools.data_models import MediaType, Video, MediaList
from sc_api_tools.rest_converters import MediaRESTConverter


class VideoManager(BaseMediaManager[Video]):
    """
    Class to manage video uploads and downloads for a certain project
    """

    _MEDIA_TYPE = MediaType.VIDEO

    def get_all_videos(self):
        """
        Get the ID's and filenames of all videos in the project

        :return: Dictionary containing the ID's (as keys) and filenames (as values)
            of the videos in the project
        """
        return self._get_all()

    def upload_video(self, video: Union[np.ndarray, str, os.PathLike]) -> Video:
        """
        Upload a video file to the server. Accepts either a path to a video file, or
        a numpy array containing pixel data for video frames.

        In case a numpy array is passed, this method expects the array to be 4
        dimensional, it's dimensions shaped as: [frames, heigth, width, channels]. The
        created video framerate will be set to 1 fps.

        :param video: full path to the video on disk, or numpy array holding the video
            pixel data
        :return: String containing the unique ID of the video, generated by Sonoma
            Creek
        """
        temporary_file_created = False
        if isinstance(video, (str, os.PathLike)):
            video_path = video
        elif isinstance(video, np.ndarray):
            try:
                n_frames, frame_height, frame_width, channels = video.shape
            except ValueError as error:
                raise ValueError(
                    f"Invalid video input shape, expected a 4D numpy array with "
                    f"dimensions representing [frames, height, width, channels]. Got "
                    f"shape {video.shape}"
                ) from error
            file_out = tempfile.NamedTemporaryFile(suffix='.avi', delete=False)
            out = cv2.VideoWriter(
                file_out.name,
                cv2.VideoWriter_fourcc('M', 'J', 'P', 'G'), 1,
                (frame_width, frame_height)
            )
            for frame in video[:, ...]:
                out.write(frame)
            out.release()
            video_path = file_out.name
            temporary_file_created = True
        else:
            raise TypeError(f"Invalid video type: {type(video)}.")

        video_dict = self._upload(video_path)
        uploaded_video = MediaRESTConverter.from_dict(
            input_dict=video_dict, media_type=Video
        )
        uploaded_video._data = video_path
        uploaded_video._needs_tempfile_deletion = temporary_file_created
        return uploaded_video

    def upload_folder(
            self, path_to_folder: str, n_videos: int = -1, return_all: bool = True
    ) -> MediaList[Video]:
        """
        Uploads all videos in a folder to the project. Returns the mapping of video
        filename to the unique ID assigned by Sonoma Creek.

        :param path_to_folder: Folder with videos to upload
        :param n_videos: Number of videos to upload from folder
        :param return_all: Set to True to return a list of all videos in the project
            after the upload. Set to False to return a list containing only the videos
            uploaded with the current call to this method. Defaults to True
        :return: MediaList containing all video's in the project
        """
        return self._upload_folder(
            path_to_folder=path_to_folder, n_media=n_videos, return_all=return_all
        )

    def download_all(self, path_to_folder: str) -> None:
        """
        Download all videos in a project to a folder on the local disk.

        :param path_to_folder: path to the folder in which the videos should be saved
        """
        self._download_all(path_to_folder)

    def delete_videos(self, videos: MediaList[Video]) -> bool:
        """
        Deletes all Video entities in `videos` from the project

        :param videos: List of Video entities to delete
        :return: True if all videos on the list were deleted successfully,
            False otherwise
        """
        return self._delete_media(media_list=videos)
